---
// ğŸš€ Pagefind é¢„åŠ è½½å™¨ç»„ä»¶ - Astro æè‡´ä¼˜åŒ–ç‰ˆæœ¬
export interface Props {
  pageType?: string;
  lang?: string;
  currentPath?: string;
  preloadStrategy?: 'immediate' | 'idle' | 'interaction' | 'smart';
  enableDebug?: boolean;
}

const {
  pageType = 'default',
  lang = 'en',
  currentPath = Astro.url.pathname,
  preloadStrategy = 'smart',
  enableDebug = import.meta.env.DEV
} = Astro.props;

const isProd = import.meta.env.PROD;
const isDev = import.meta.env.DEV;

const getPreloadConfig = () => {
  return {
    pageType,
    lang,
    currentPath,
    strategy: preloadStrategy,
    debug: enableDebug,
    isProd,
    isDev
  };
};

const config = getPreloadConfig();


---

<!-- ğŸš€ Pagefind é¢„åŠ è½½å™¨ - Astro æè‡´ä¼˜åŒ–ç‰ˆæœ¬ï¼Œä½¿ç”¨Partytownä¼˜åŒ– -->
<script type="text/partytown" define:vars={{ 
  isProd, 
  isDev, 
  pageType, 
  lang, 
  currentPath,
  config,
  enableDebug
}}>
  // ğŸš€ Astro æè‡´ä¼˜åŒ–ç‰ˆæœ¬ - åˆ©ç”¨æ‰€æœ‰ Astro ç‰¹æ€§
  
  // æ„å»ºæ—¶å˜é‡æ³¨å…¥
  const PAGE_TYPE = pageType;
  const CURRENT_LANG = lang;
  const CURRENT_PATH = currentPath;
  const IS_PROD = isProd;
  const IS_DEV = isDev;
  const CONFIG = config;
  const ENABLE_DEBUG = enableDebug;
  
  // æ€§èƒ½ä¼˜åŒ–ï¼šé¿å…é‡å¤åˆå§‹åŒ–
  if (window.pagefindPreloaderInitialized) {
    return;
  }
  
  // ğŸ¯ æ™ºèƒ½é¢„åŠ è½½å™¨ç±»
  class PagefindPreloader {
    constructor() {
      this.isPreloaded = false;
      this.preloadPromise = null;
      this.observers = [];
      this.startTime = Date.now();
      this.isSearchPage = CURRENT_PATH.includes('/search');
    }
    
    // ğŸ¯ ç­–ç•¥1: ç«‹å³é¢„åŠ è½½
    async preloadImmediate() {
      if (this.isPreloaded) return;
      
      await this.preloadPagefind();
    }
    
    // ğŸ¯ ç­–ç•¥2: æ™ºèƒ½é¢„åŠ è½½ç­–ç•¥
    async preloadWithStrategy() {
      if (this.isPreloaded) return;
      
      switch (CONFIG.strategy) {
        case 'immediate':
          await this.preloadImmediate();
          break;
        case 'idle':
          this.preloadOnIdle();
          break;
        case 'interaction':
          this.preloadOnInteraction();
          break;
        case 'smart':
        default:
          this.preloadSmart();
          break;
      }
    }
    
    // ğŸ¯ ç©ºé—²æ—¶é¢„åŠ è½½
    preloadOnIdle() {
      if ('requestIdleCallback' in window) {
        requestIdleCallback(() => this.preloadPagefind(), { timeout: 2000 });
      } else {
        setTimeout(() => this.preloadPagefind(), 1000);
      }
    }
    
    // ğŸ¯ äº¤äº’æ—¶é¢„åŠ è½½
    preloadOnInteraction() {
      let hasInteraction = false;
      
      const interactionHandler = () => {
        if (!hasInteraction) {
          hasInteraction = true;
          setTimeout(() => this.preloadPagefind(), 500);
          this.cleanupObservers();
        }
      };
      
      ['scroll', 'mousemove', 'click', 'touchstart'].forEach(event => {
        window.addEventListener(event, interactionHandler, { passive: true, once: true });
        this.observers.push(() => window.removeEventListener(event, interactionHandler));
      });
      
      // å¤‡ç”¨æ–¹æ¡ˆ
      setTimeout(() => {
        if (!hasInteraction && !this.isPreloaded) {
          this.preloadPagefind();
        }
      }, 3000);
    }
    
    // ğŸ¯ æ™ºèƒ½é¢„åŠ è½½ç­–ç•¥
    preloadSmart() {
      // ç»„åˆå¤šç§ç­–ç•¥
      this.preloadOnIdle();
      this.preloadOnInteraction();
    }
    
    // ğŸ¯ æœç´¢é¡µé¢ä¸“ç”¨é¢„åŠ è½½
    async loadForSearchPage() {
      if (this.isPreloaded) return;
      
      if (ENABLE_DEBUG) {
        console.log('ğŸ” æœç´¢é¡µé¢ - ç«‹å³é¢„åŠ è½½ Pagefind');
      }
      
      await this.preloadPagefind();
    }
    
    // ğŸ¯ æ ¸å¿ƒé¢„åŠ è½½é€»è¾‘
    async preloadPagefind() {
      if (this.isPreloaded && this.preloadPromise) {
        return this.preloadPromise;
      }
      
      this.preloadPromise = (async () => {
        try {
          const loadStartTime = Date.now();
          
          // ğŸ¯ é¢„åŠ è½½ Pagefind CSS å’Œ JS æ–‡ä»¶
          await this.preloadPagefindAssets();
          
          const loadEndTime = Date.now();
          const loadDuration = loadEndTime - loadStartTime;
          
          // æ ‡è®°ä¸ºå·²é¢„åŠ è½½
          this.isPreloaded = true;
          window.pagefindPreloaded = true;
          

          
          // è§¦å‘é¢„åŠ è½½å®Œæˆäº‹ä»¶
          window.dispatchEvent(new CustomEvent('pagefind:preloaded', {
            detail: {
              pageType: PAGE_TYPE,
              lang: CURRENT_LANG,
              timestamp: Date.now(),
              loadDuration,
              strategy: CONFIG.strategy
            }
          }));
          
          // æ¸…ç†è§‚å¯Ÿå™¨
          this.cleanupObservers();
          
        } catch (error) {
          console.warn('âš ï¸ Pagefind é¢„åŠ è½½å¤±è´¥:', error);
          
          // å¼€å‘ç¯å¢ƒæ˜¾ç¤ºè¯¦ç»†é”™è¯¯
          if (IS_DEV) {
            console.error('Pagefind é¢„åŠ è½½é”™è¯¯è¯¦æƒ…:', {
              error: error.message,
              stack: error.stack,
              pageType: PAGE_TYPE,
              lang: CURRENT_LANG,
              path: CURRENT_PATH,
              config: CONFIG
            });
          }
        }
      })();
      
      return this.preloadPromise;
    }
    
    // ğŸ¯ é¢„åŠ è½½ Pagefind èµ„æºæ–‡ä»¶
    async preloadPagefindAssets() {
      const assets = [
        // Pagefind CSS æ–‡ä»¶
        '/pagefind/pagefind-ui.css',
        // Pagefind JS æ–‡ä»¶
        '/pagefind/pagefind-ui.js'
      ];
      
      const preloadPromises = assets.map(asset => {
        return new Promise((resolve, reject) => {
          if (asset.endsWith('.css')) {
            // é¢„åŠ è½½ CSS
            const link = document.createElement('link');
            link.rel = 'preload';
            link.href = asset;
            link.as = 'style';
            link.onload = () => resolve();
            link.onerror = () => reject(new Error(`Failed to preload CSS: ${asset}`));
            document.head.appendChild(link);
          } else if (asset.endsWith('.js')) {
            // é¢„åŠ è½½ JS
            const script = document.createElement('script');
            script.src = asset;
            script.async = true;
            script.onload = () => resolve();
            script.onerror = () => reject(new Error(`Failed to preload JS: ${asset}`));
            document.head.appendChild(script);
          }
        });
      });
      
      await Promise.all(preloadPromises);
    }
    
    // ğŸ§¹ æ¸…ç†è§‚å¯Ÿå™¨
    cleanupObservers() {
      this.observers.forEach(cleanup => cleanup());
      this.observers = [];
    }
    
    // ğŸš€ å¯åŠ¨é¢„åŠ è½½
    async start() {
      if (this.isSearchPage) {
        await this.loadForSearchPage();
      } else {
        await this.preloadWithStrategy();
      }
    }
  }
  
  // ğŸ¯ åˆå§‹åŒ–é¢„åŠ è½½å™¨
  const preloader = new PagefindPreloader();
  
  // ğŸš€ å¯åŠ¨é¢„åŠ è½½ç­–ç•¥
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => preloader.start());
  } else {
    preloader.start();
  }
  
  // ğŸ” å¼€å‘ç¯å¢ƒè°ƒè¯•å·¥å…·
  if (IS_DEV && ENABLE_DEBUG) {
    window.pagefindDebug = {
      preloader,
      config: CONFIG,
      getStatus: () => ({
        isPreloaded: window.pagefindPreloaded,
        pageType: PAGE_TYPE,
        lang: CURRENT_LANG,
        path: CURRENT_PATH,
        isSearchPage: preloader.isSearchPage,
        strategy: CONFIG.strategy,
        startTime: preloader.startTime
      }),
      forcePreload: () => preloader.preloadPagefind(),
      reset: () => {
        window.pagefindPreloaded = false;
        preloader.isPreloaded = false;
        preloader.preloadPromise = null;
      },
      changeStrategy: (newStrategy) => {
        CONFIG.strategy = newStrategy;

      }
    };
  }
  
  // æ ‡è®°ä¸ºå·²åˆå§‹åŒ–
  window.pagefindPreloaderInitialized = true;
</script>
