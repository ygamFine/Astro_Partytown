---
// ðŸŽ¬ åŠ¨ç”»ç³»ç»Ÿç»„ä»¶ - Astro æžè‡´ä¼˜åŒ–ç‰ˆæœ¬
export interface Props {
  enableAnimations?: boolean;
  enableCounters?: boolean;
  enableDebug?: boolean;
  animationStrategy?: 'immediate' | 'idle' | 'interaction' | 'smart';
}

const {
  enableAnimations = true,
  enableCounters = true,
  enableDebug = import.meta.env.DEV,
  animationStrategy = 'smart'
} = Astro.props;

// æž„å»ºæ—¶çŽ¯å¢ƒæ£€æµ‹
const isProd = import.meta.env.PROD;
const isDev = import.meta.env.DEV;

// åŠ¨ç”»é…ç½®
const getAnimationConfig = () => {
  return {
    enableAnimations,
    enableCounters,
    strategy: animationStrategy,
    debug: enableDebug,
    isProd,
    isDev
  };
};

const config = getAnimationConfig();


---

<!-- ðŸŽ¬ åŠ¨ç”»ç³»ç»Ÿ - Astro æžè‡´ä¼˜åŒ–ç‰ˆæœ¬ -->
<script define:vars={{ 
  isProd, 
  isDev, 
  enableAnimations, 
  enableCounters,
  config,
  enableDebug
}}>
  // ðŸŽ¬ Astro æžè‡´ä¼˜åŒ–ç‰ˆæœ¬ - åˆ©ç”¨æ‰€æœ‰ Astro ç‰¹æ€§
  
  // æž„å»ºæ—¶å˜é‡æ³¨å…¥
  const ENABLE_ANIMATIONS = enableAnimations;
  const ENABLE_COUNTERS = enableCounters;
  const IS_PROD = isProd;
  const IS_DEV = isDev;
  const CONFIG = config;
  const ENABLE_DEBUG = enableDebug;
  
  // æ€§èƒ½ä¼˜åŒ–ï¼šé¿å…é‡å¤åˆå§‹åŒ–
  if (window.animationSystemInitialized) {
    return;
  }
  
  // ðŸŽ¯ æ™ºèƒ½åŠ¨ç”»ç³»ç»Ÿç±»
  class AnimationSystem {
    constructor() {
      this.isInitialized = false;
      this.observers = new Map();
      this.startTime = Date.now();
      this.animationElements = new Set();
      this.counterElements = new Set();
    }
    
    // ðŸŽ¯ ç­–ç•¥1: ç«‹å³åˆå§‹åŒ–
    async initImmediate() {
      if (this.isInitialized) return;
      
      await this.initializeSystem();
    }
    
    // ðŸŽ¯ ç­–ç•¥2: æ™ºèƒ½åˆå§‹åŒ–ç­–ç•¥
    async initWithStrategy() {
      if (this.isInitialized) return;
      
      switch (CONFIG.strategy) {
        case 'immediate':
          await this.initImmediate();
          break;
        case 'idle':
          this.initOnIdle();
          break;
        case 'interaction':
          this.initOnInteraction();
          break;
        case 'smart':
        default:
          this.initSmart();
          break;
      }
    }
    
    // ðŸŽ¯ ç©ºé—²æ—¶åˆå§‹åŒ–
    initOnIdle() {
      if ('requestIdleCallback' in window) {
        requestIdleCallback(() => this.initializeSystem(), { timeout: 2000 });
      } else {
        setTimeout(() => this.initializeSystem(), 1000);
      }
    }
    
    // ðŸŽ¯ äº¤äº’æ—¶åˆå§‹åŒ–
    initOnInteraction() {
      let hasInteraction = false;
      
      const interactionHandler = () => {
        if (!hasInteraction) {
          hasInteraction = true;
          setTimeout(() => this.initializeSystem(), 500);
          this.cleanupObservers();
        }
      };
      
      ['scroll', 'mousemove', 'click', 'touchstart'].forEach(event => {
        window.addEventListener(event, interactionHandler, { passive: true, once: true });
        this.observers.set(event, () => window.removeEventListener(event, interactionHandler));
      });
      
      // å¤‡ç”¨æ–¹æ¡ˆ
      setTimeout(() => {
        if (!hasInteraction && !this.isInitialized) {
          this.initializeSystem();
        }
      }, 3000);
    }
    
    // ðŸŽ¯ æ™ºèƒ½åˆå§‹åŒ–ç­–ç•¥
    initSmart() {
      // ç»„åˆå¤šç§ç­–ç•¥
      this.initOnIdle();
      this.initOnInteraction();
    }
    
    // ðŸŽ¯ æ ¸å¿ƒåˆå§‹åŒ–é€»è¾‘
    async initializeSystem() {
      if (this.isInitialized) return;
      
      try {
        const initStartTime = Date.now();
        
        // åˆå§‹åŒ–åŠ¨ç”»ç³»ç»Ÿ
        if (ENABLE_ANIMATIONS) {
          this.initAnimationSystem();
        }
        
        // åˆå§‹åŒ–è®¡æ•°å™¨ç³»ç»Ÿ
        if (ENABLE_COUNTERS) {
          this.initCounterSystem();
        }
        
        const initEndTime = Date.now();
        const initDuration = initEndTime - initStartTime;
        
        // æ ‡è®°ä¸ºå·²åˆå§‹åŒ–
        this.isInitialized = true;
        window.animationSystemInitialized = true;
        

        
        // è§¦å‘åˆå§‹åŒ–å®Œæˆäº‹ä»¶
        window.dispatchEvent(new CustomEvent('animation:ready', {
          detail: {
            enableAnimations: ENABLE_ANIMATIONS,
            enableCounters: ENABLE_COUNTERS,
            strategy: CONFIG.strategy,
            timestamp: Date.now(),
            initDuration
          }
        }));
        
        // æ¸…ç†è§‚å¯Ÿå™¨
        this.cleanupObservers();
        
      } catch (error) {
        console.warn('âš ï¸ åŠ¨ç”»ç³»ç»Ÿåˆå§‹åŒ–å¤±è´¥:', error);
        
        // å¼€å‘çŽ¯å¢ƒæ˜¾ç¤ºè¯¦ç»†é”™è¯¯
        if (IS_DEV) {
          console.error('åŠ¨ç”»ç³»ç»Ÿåˆå§‹åŒ–é”™è¯¯è¯¦æƒ…:', {
            error: error.message,
            stack: error.stack,
            config: CONFIG
          });
        }
      }
    }
    
    // ðŸŽ¯ åˆå§‹åŒ–åŠ¨ç”»ç³»ç»Ÿ
    initAnimationSystem() {
      // æ£€æŸ¥æµè§ˆå™¨æ”¯æŒ
      if (!window.IntersectionObserver) {
        // ä¸æ”¯æŒçš„è¯ç›´æŽ¥æ˜¾ç¤ºæ‰€æœ‰å…ƒç´ 
        document.querySelectorAll('.animate-fade-up, .animate-fade-left, .animate-fade-right, .animate-scale-up').forEach(el => {
          el.classList.add('animate-in');
          this.animationElements.add(el);
        });
        return;
      }

      // åˆ›å»ºè§‚å¯Ÿå™¨
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            entry.target.classList.add('animate-in');
            observer.unobserve(entry.target);
            this.animationElements.add(entry.target);
          }
        });
      }, {
        threshold: 0.1,
        rootMargin: '50px'
      });

      // è§‚å¯ŸåŠ¨ç”»å…ƒç´ 
      document.querySelectorAll('.animate-fade-up, .animate-fade-left, .animate-fade-right, .animate-scale-up').forEach(el => {
        observer.observe(el);
      });
      
      this.observers.set('animation', observer);
    }
    
    // ðŸŽ¯ åˆå§‹åŒ–è®¡æ•°å™¨ç³»ç»Ÿ
    initCounterSystem() {
      // æ•°å­—è®¡æ•°åŠ¨ç”»
      const animateCounter = (element, target, duration = 2000) => {
        let start = 0;
        const increment = target / (duration / 16);
        
        function update() {
          start += increment;
          if (start < target) {
            element.textContent = Math.floor(start).toLocaleString();
            requestAnimationFrame(update);
          } else {
            element.textContent = target.toLocaleString();
          }
        }
        
        update();
      };

      // æ£€æŸ¥æµè§ˆå™¨æ”¯æŒ
      if (!window.IntersectionObserver) {
        // ä¸æ”¯æŒçš„è¯ç›´æŽ¥æ‰§è¡Œæ‰€æœ‰è®¡æ•°å™¨
        document.querySelectorAll('.counter-number[data-count]').forEach(el => {
          const target = el.dataset.count;
          if (target) {
            animateCounter(el, parseInt(target));
            this.counterElements.add(el);
          }
        });
        return;
      }

      // ç»Ÿè®¡æ•°å­—è§‚å¯Ÿå™¨
      const counterObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const target = entry.target.dataset.count;
            if (target) {
              animateCounter(entry.target, parseInt(target));
              counterObserver.unobserve(entry.target);
              this.counterElements.add(entry.target);
            }
          }
        });
      }, { threshold: 0.5 });

      // è§‚å¯Ÿè®¡æ•°å™¨
      document.querySelectorAll('.counter-number[data-count]').forEach(el => {
        counterObserver.observe(el);
      });
      
      this.observers.set('counter', counterObserver);
    }
    
    // ðŸ§¹ æ¸…ç†è§‚å¯Ÿå™¨
    cleanupObservers() {
      this.observers.forEach((cleanup, key) => {
        if (typeof cleanup === 'function') {
          cleanup();
        } else if (cleanup && typeof cleanup.disconnect === 'function') {
          cleanup.disconnect();
        }
      });
      this.observers.clear();
    }
    
    // ðŸš€ å¯åŠ¨åŠ¨ç”»ç³»ç»Ÿ
    async start() {
      await this.initWithStrategy();
    }
    
    // ðŸ“Š èŽ·å–ç»Ÿè®¡ä¿¡æ¯
    getStats() {
      return {
        isInitialized: this.isInitialized,
        animationElements: this.animationElements.size,
        counterElements: this.counterElements.size,
        observers: this.observers.size,
        startTime: this.startTime
      };
    }
  }
  
  // ðŸŽ¯ åˆå§‹åŒ–åŠ¨ç”»ç³»ç»Ÿ
  const animationSystem = new AnimationSystem();
  
  // ðŸš€ å¯åŠ¨åŠ¨ç”»ç³»ç»Ÿ
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => animationSystem.start());
  } else {
    animationSystem.start();
  }
  
  // ðŸ” å¼€å‘çŽ¯å¢ƒè°ƒè¯•å·¥å…·
  if (IS_DEV && ENABLE_DEBUG) {
    window.animationDebug = {
      animationSystem,
      config: CONFIG,
      getStats: () => animationSystem.getStats(),
      forceInit: () => animationSystem.initImmediate(),
      reset: () => {
        window.animationSystemInitialized = false;
        animationSystem.isInitialized = false;
        animationSystem.animationElements.clear();
        animationSystem.counterElements.clear();
        animationSystem.cleanupObservers();
      },
      changeStrategy: (newStrategy) => {
        CONFIG.strategy = newStrategy;
        
      }
    };
  }
</script>
