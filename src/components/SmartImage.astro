---
import { Image } from 'astro:assets';
import { getOptimizedImage, getImageDimensions, isOptimizable } from '../data/imageMapping.js';
import OptimizedImage from './OptimizedImage.astro';

export interface Props {
  src: string;
  alt: string;
  width?: number;
  height?: number;
  loading?: 'lazy' | 'eager';
  decoding?: 'async' | 'sync' | 'auto';
  sizes?: string;
  className?: string;
  priority?: boolean;
  fallbackSrc?: string;
  placeholder?: boolean;
  blur?: boolean;
}

const {
  src,
  alt,
  width,
  height,
  loading = 'lazy',
  decoding = 'async',
  sizes = '(max-width: 768px) 100vw, (max-width: 1024px) 50vw, 33vw',
  className = '',
  priority = false,
  fallbackSrc = '/images/placeholder.webp',
  placeholder = false,
  blur = false
} = Astro.props;

// 检查是否可以使用Astro的Image组件
const optimizedImage = getOptimizedImage(src);
const isStaticImage = optimizedImage !== null;

// 获取图片尺寸
const imageDimensions = getImageDimensions(src) as { width: number; height: number };
const finalWidth = width || imageDimensions.width;
const finalHeight = height || imageDimensions.height;

// 检查是否可以被优化
const canBeOptimized = isOptimizable(src);
---

{isStaticImage ? (
  <!-- 使用Astro的Image组件处理静态图片 -->
  <Image
    src={optimizedImage as any}
    alt={alt}
    width={finalWidth}
    height={finalHeight}
    loading={loading}
    decoding={decoding}
    sizes={sizes}
    class={className}
    fetchpriority={priority ? 'high' : 'auto'}
  />
) : canBeOptimized ? (
  <!-- 使用优化的img标签处理可优化的动态图片 -->
  <OptimizedImage
    src={src}
    alt={alt}
    width={finalWidth}
    height={finalHeight}
    loading={loading}
    decoding={decoding}
    sizes={sizes}
    className={className}
    priority={priority}
    fallbackSrc={fallbackSrc}
    placeholder={placeholder}
    blur={blur}
  />
) : (
  <!-- 使用普通img标签处理外部图片 -->
  <img
    src={src}
    alt={alt}
    width={finalWidth}
    height={finalHeight}
    loading={loading}
    decoding={decoding}
    sizes={sizes}
    class={`dynamic-image ${className}`.trim()}
    fetchpriority={priority ? 'high' : 'auto'}
    onerror={`this.onerror=null; this.src='${fallbackSrc}';`}
  />
)}

<style>
  .dynamic-image {
    width: 100%;
    height: auto;
    display: block;
    transition: opacity 0.3s ease;
  }

  .dynamic-image[loading="lazy"] {
    opacity: 0;
  }

  .dynamic-image[loading="lazy"].loaded {
    opacity: 1;
  }

  /* 响应式优化 */
  @media (max-width: 768px) {
    .dynamic-image {
      width: 100%;
    }
  }

  @media (max-width: 1024px) {
    .dynamic-image {
      width: 100%;
    }
  }
</style>

<script>
  // 处理动态图片的加载
  document.addEventListener('DOMContentLoaded', function() {
    const dynamicImages = document.querySelectorAll('.dynamic-image[loading="lazy"]');
    
    if ('IntersectionObserver' in window) {
      const imageObserver = new IntersectionObserver((entries, observer) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const img = entry.target as HTMLImageElement;
            loadDynamicImage(img);
            observer.unobserve(img);
          }
        });
      }, {
        rootMargin: '50px 0px',
        threshold: 0.1
      });

      dynamicImages.forEach(img => imageObserver.observe(img));
    } else {
      // 降级处理
      dynamicImages.forEach(img => loadDynamicImage(img as HTMLImageElement));
    }
  });

  function loadDynamicImage(img: HTMLImageElement) {
    img.addEventListener('load', function() {
      img.classList.add('loaded');
    });

    img.addEventListener('error', function() {
      const fallback = img.getAttribute('data-fallback') || '/images/placeholder.webp';
      if (img.src !== fallback) {
        img.src = fallback;
      }
    });
  }
</script> 